/**
 * Angular Tutorial REST API
 * This is the REST API that is to be used during the Angular Basics course. The API provides the basic functions and elements to build a simple blog. <br/>Building parts of a simple blog webpage are PAGE, ARTICLE and FILE. For simplicity only IMAGES are allowed to be saved. <br/>Usually all methods that don't modify the content will be accessible without authentication. In order to change the content you will have to be authenticated and have the respective user rights to modify the content. User authentication is done via keycloak - an open source user management server. Detailed description will be added later
 *
 * OpenAPI spec version: 1.0
 * Contact: martin.dobrev@akros.ch
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';

import { BlogFileCollectionDTO } from '../model/blogFileCollectionDTO';
import { BlogFileDTO } from '../model/blogFileDTO';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class FileControllerService {

    protected basePath = 'https://localhost:8000';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * deleteFile
     * 
     * @param id id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteFileUsingDELETE(id: number, observe?: 'body', reportProgress?: boolean): Observable<boolean>;
    public deleteFileUsingDELETE(id: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<boolean>>;
    public deleteFileUsingDELETE(id: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<boolean>>;
    public deleteFileUsingDELETE(id: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteFileUsingDELETE.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<boolean>(`${this.basePath}/api/v1/files/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * getFile
     * 
     * @param id id
     * @param size size
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getFileUsingGET(id: number, size?: string, observe?: 'body', reportProgress?: boolean): Observable<string>;
    public getFileUsingGET(id: number, size?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;
    public getFileUsingGET(id: number, size?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public getFileUsingGET(id: number, size?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getFileUsingGET.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (size !== undefined && size !== null) {
            queryParameters = queryParameters.set('size', <any>size);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<string>(`${this.basePath}/api/v1/files/${encodeURIComponent(String(id))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * getFiles
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getFilesUsingGET(observe?: 'body', reportProgress?: boolean): Observable<BlogFileCollectionDTO>;
    public getFilesUsingGET(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<BlogFileCollectionDTO>>;
    public getFilesUsingGET(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<BlogFileCollectionDTO>>;
    public getFilesUsingGET(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<BlogFileCollectionDTO>(`${this.basePath}/api/v1/files`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * uploadFile
     * 
     * @param file file
     * @param authenticated 
     * @param authorities0Authority 
     * @param credentials 
     * @param details 
     * @param name 
     * @param principal 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public uploadFileUsingPOST(file: Blob, authenticated?: any, authorities0Authority?: any, credentials?: any, details?: any, name?: any, principal?: any, observe?: 'body', reportProgress?: boolean): Observable<BlogFileDTO>;
    public uploadFileUsingPOST(file: Blob, authenticated?: any, authorities0Authority?: any, credentials?: any, details?: any, name?: any, principal?: any, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<BlogFileDTO>>;
    public uploadFileUsingPOST(file: Blob, authenticated?: any, authorities0Authority?: any, credentials?: any, details?: any, name?: any, principal?: any, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<BlogFileDTO>>;
    public uploadFileUsingPOST(file: Blob, authenticated?: any, authorities0Authority?: any, credentials?: any, details?: any, name?: any, principal?: any, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (file === null || file === undefined) {
            throw new Error('Required parameter file was null or undefined when calling uploadFileUsingPOST.');
        }







        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'multipart/form-data'
        ];

        const canConsumeForm = this.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): void; };
        let useForm = false;
        let convertFormParamsToString = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        // see https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        }

        if (authenticated !== undefined) {
            formParams.append('authenticated', <any>authenticated);
        }
        if (authorities0Authority !== undefined) {
            formParams.append('authorities[0].authority', <any>authorities0Authority);
        }
        if (credentials !== undefined) {
            formParams.append('credentials', <any>credentials);
        }
        if (details !== undefined) {
            formParams.append('details', <any>details);
        }
        if (file !== undefined) {
            formParams.append('file', <any>file);
        }
        if (name !== undefined) {
            formParams.append('name', <any>name);
        }
        if (principal !== undefined) {
            formParams.append('principal', <any>principal);
        }

        return this.httpClient.post<BlogFileDTO>(`${this.basePath}/api/v1/files`,
            convertFormParamsToString ? formParams.toString() : formParams,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
