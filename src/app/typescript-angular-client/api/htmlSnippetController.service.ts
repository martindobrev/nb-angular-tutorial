/**
 * Angular Tutorial REST API
 * This is the REST API that is to be used during the Angular Basics course. The API provides the basic functions and elements to build a simple blog. <br/>Building parts of a simple blog webpage are PAGE, ARTICLE and FILE. For simplicity only IMAGES are allowed to be saved. <br/>Usually all methods that don't modify the content will be accessible without authentication. In order to change the content you will have to be authenticated and have the respective user rights to modify the content. User authentication is done via keycloak - an open source user management server. Detailed description will be added later
 *
 * OpenAPI spec version: 1.0
 * Contact: martin.dobrev@akros.ch
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';

import { HtmlSnippet } from '../model/htmlSnippet';
import { HtmlSnippetCollectionDTO } from '../model/htmlSnippetCollectionDTO';
import { HtmlSnippetDTO } from '../model/htmlSnippetDTO';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class HtmlSnippetControllerService {

    protected basePath = 'https://localhost:8000';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * createSnippet
     * 
     * @param htmlSnippet htmlSnippet
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createSnippetUsingPOST(htmlSnippet: HtmlSnippet, observe?: 'body', reportProgress?: boolean): Observable<HtmlSnippetDTO>;
    public createSnippetUsingPOST(htmlSnippet: HtmlSnippet, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<HtmlSnippetDTO>>;
    public createSnippetUsingPOST(htmlSnippet: HtmlSnippet, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<HtmlSnippetDTO>>;
    public createSnippetUsingPOST(htmlSnippet: HtmlSnippet, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (htmlSnippet === null || htmlSnippet === undefined) {
            throw new Error('Required parameter htmlSnippet was null or undefined when calling createSnippetUsingPOST.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<HtmlSnippetDTO>(`${this.basePath}/api/v1/snippets`,
            htmlSnippet,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * editSnippet
     * 
     * @param htmlSnippet htmlSnippet
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public editSnippetUsingPUT(htmlSnippet: HtmlSnippet, observe?: 'body', reportProgress?: boolean): Observable<HtmlSnippetDTO>;
    public editSnippetUsingPUT(htmlSnippet: HtmlSnippet, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<HtmlSnippetDTO>>;
    public editSnippetUsingPUT(htmlSnippet: HtmlSnippet, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<HtmlSnippetDTO>>;
    public editSnippetUsingPUT(htmlSnippet: HtmlSnippet, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (htmlSnippet === null || htmlSnippet === undefined) {
            throw new Error('Required parameter htmlSnippet was null or undefined when calling editSnippetUsingPUT.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<HtmlSnippetDTO>(`${this.basePath}/api/v1/snippets/${encodeURIComponent(String(htmlSnippet.id))}`,
            htmlSnippet,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * getHtmlSnippetByName
     * 
     * @param name name
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getHtmlSnippetByNameUsingGET(name: string, observe?: 'body', reportProgress?: boolean): Observable<HtmlSnippetDTO>;
    public getHtmlSnippetByNameUsingGET(name: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<HtmlSnippetDTO>>;
    public getHtmlSnippetByNameUsingGET(name: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<HtmlSnippetDTO>>;
    public getHtmlSnippetByNameUsingGET(name: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getHtmlSnippetByNameUsingGET.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<HtmlSnippetDTO>(`${this.basePath}/api/v1/snippets/${encodeURIComponent(String(name))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * getHtmlSnippets
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getHtmlSnippetsUsingGET(observe?: 'body', reportProgress?: boolean): Observable<HtmlSnippetCollectionDTO>;
    public getHtmlSnippetsUsingGET(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<HtmlSnippetCollectionDTO>>;
    public getHtmlSnippetsUsingGET(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<HtmlSnippetCollectionDTO>>;
    public getHtmlSnippetsUsingGET(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<HtmlSnippetCollectionDTO>(`${this.basePath}/api/v1/snippets`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
