/**
 * Angular Tutorial REST API
 * This is the REST API that is to be used during the Angular Basics course. The API provides the basic functions and elements to build a simple blog. <br/>Building parts of a simple blog webpage are PAGE, ARTICLE and FILE. For simplicity only IMAGES are allowed to be saved. <br/>Usually all methods that don't modify the content will be accessible without authentication. In order to change the content you will have to be authenticated and have the respective user rights to modify the content. User authentication is done via keycloak - an open source user management server. Detailed description will be added later
 *
 * OpenAPI spec version: 1.0
 * Contact: martin.dobrev@akros.ch
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';

import { Article } from '../model/article';
import { ArticleCollectionDTO } from '../model/articleCollectionDTO';
import { ArticleDTO } from '../model/articleDTO';
import { ArticleInfoDTO } from '../model/articleInfoDTO';
import { Principal } from '../model/principal';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class ArticleControllerService {

    protected basePath = 'https://localhost:8000';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * createArticle
     * 
     * @param article article
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createArticleUsingPOST(article: Article, observe?: 'body', reportProgress?: boolean): Observable<ArticleDTO>;
    public createArticleUsingPOST(article: Article, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ArticleDTO>>;
    public createArticleUsingPOST(article: Article, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ArticleDTO>>;
    public createArticleUsingPOST(article: Article, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (article === null || article === undefined) {
            throw new Error('Required parameter article was null or undefined when calling createArticleUsingPOST.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<ArticleDTO>(`${this.basePath}/api/v1/articles`,
            article,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * editArticle
     * 
     * @param article article
     * @param articleId articleId
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public editArticleUsingPUT(article: Article, articleId: number, observe?: 'body', reportProgress?: boolean): Observable<ArticleDTO>;
    public editArticleUsingPUT(article: Article, articleId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ArticleDTO>>;
    public editArticleUsingPUT(article: Article, articleId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ArticleDTO>>;
    public editArticleUsingPUT(article: Article, articleId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (article === null || article === undefined) {
            throw new Error('Required parameter article was null or undefined when calling editArticleUsingPUT.');
        }

        if (articleId === null || articleId === undefined) {
            throw new Error('Required parameter articleId was null or undefined when calling editArticleUsingPUT.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<ArticleDTO>(`${this.basePath}/api/v1/articles/${encodeURIComponent(String(articleId))}`,
            article,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * This will get a list of available articles
     * Articles content will only be available as markdown (content property). To get the parsed HTML in the field htmlContent, get the article by single ID
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAllArticlesUsingGET(observe?: 'body', reportProgress?: boolean): Observable<ArticleCollectionDTO>;
    public getAllArticlesUsingGET(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ArticleCollectionDTO>>;
    public getAllArticlesUsingGET(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ArticleCollectionDTO>>;
    public getAllArticlesUsingGET(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<ArticleCollectionDTO>(`${this.basePath}/api/v1/articles`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * getArticleInfo
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getArticleInfoUsingGET(observe?: 'body', reportProgress?: boolean): Observable<ArticleInfoDTO>;
    public getArticleInfoUsingGET(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ArticleInfoDTO>>;
    public getArticleInfoUsingGET(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ArticleInfoDTO>>;
    public getArticleInfoUsingGET(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<ArticleInfoDTO>(`${this.basePath}/api/v1/info/articles`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * getArticle
     * 
     * @param articleId articleId
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getArticleUsingGET(articleId: number, observe?: 'body', reportProgress?: boolean): Observable<ArticleDTO>;
    public getArticleUsingGET(articleId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ArticleDTO>>;
    public getArticleUsingGET(articleId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ArticleDTO>>;
    public getArticleUsingGET(articleId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (articleId === null || articleId === undefined) {
            throw new Error('Required parameter articleId was null or undefined when calling getArticleUsingGET.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<ArticleDTO>(`${this.basePath}/api/v1/articles/${encodeURIComponent(String(articleId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * getCompleteVisibleArticles
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getCompleteVisibleArticlesUsingGET(observe?: 'body', reportProgress?: boolean): Observable<ArticleCollectionDTO>;
    public getCompleteVisibleArticlesUsingGET(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ArticleCollectionDTO>>;
    public getCompleteVisibleArticlesUsingGET(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ArticleCollectionDTO>>;
    public getCompleteVisibleArticlesUsingGET(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<ArticleCollectionDTO>(`${this.basePath}/api/v1/complete-articles`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * getPrincipal
     * 
     * @param name 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getPrincipalUsingGET(name?: string, observe?: 'body', reportProgress?: boolean): Observable<Principal>;
    public getPrincipalUsingGET(name?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Principal>>;
    public getPrincipalUsingGET(name?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Principal>>;
    public getPrincipalUsingGET(name?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (name !== undefined && name !== null) {
            queryParameters = queryParameters.set('name', <any>name);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Principal>(`${this.basePath}/api/v1/user`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
